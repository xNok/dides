package deployment

import (
	"context"
	"errors"
	"fmt"
)

const (
	lockKey = "deployment"
)

//go:generate mockgen -source=trigger.go -destination=mocks/mock_store.go -package=mocks
//go:generate mockgen -source=strategy.go -destination=mocks/mock_strategy.go -package=mocks

var (
	ErrInvalidDeploymentRequest      = errors.New("invalid deployment request")
	ErrRolloutInProgress             = errors.New("deployment rollout in progress")
	ErrDeploymentNotFound            = errors.New("deployment not found")
	ErrMoreThanOneInflightDeployment = errors.New("more than one inflight deployment found")
	ErrNoPreviousDeploymentFound     = errors.New("no previous successful deployment found for rollback")
	ErrFailureThresholdExceeded      = errors.New("deployment failure threshold exceeded")
)

type Store interface {
	Save(req *DeploymentRecord) error
	GetByStatus(status DeploymentStatus) ([]*DeploymentRecord, error)
	Update(record *DeploymentRecord) error
	GetByLabelsAndStatus(labels map[string]string, status DeploymentStatus) ([]*DeploymentRecord, error)
}

type Locker interface {
	Lock(ctx context.Context, key string) error
	Unlock(ctx context.Context, key string) error
}

type TriggerService struct {
	store    Store
	lock     Locker
	strategy DeploymentStrategy
}

func NewTriggerService(store Store, lock Locker, strategy DeploymentStrategy) *TriggerService {
	return &TriggerService{
		store:    store,
		lock:     lock,
		strategy: strategy,
	}
}

// Validate the deployment request
func (r DeploymentRequest) Validate() error {
	// TODO: validate the content of the request (eg. is the version valid)
	if r.CodeVersion == "" {
		return ErrInvalidDeploymentRequest
	}

	if r.Configuration.BatchSize <= 0 {
		return ErrInvalidDeploymentRequest
	}

	if r.Configuration.FailureThreshold < 0 {
		return ErrInvalidDeploymentRequest
	}

	return nil
}

// TriggerDeployment initiates a new deployment
func (s *TriggerService) TriggerDeployment(ctx context.Context, req *DeploymentRequest) error {
	if err := req.Validate(); err != nil {
		return err
	}

	// Concurrency check we need a lock here in case two or more requests has arrived
	if err := s.lock.Lock(ctx, lockKey); err != nil {
		return err
	}
	defer s.lock.Unlock(ctx, lockKey)

	// 1. Feature Request: If a deployment rollout is in progress, a new deployment rollout cannot start
	if s.isRolloutInProgress() {
		return ErrRolloutInProgress
	}

	// 2. Save the deployment record
	record := &DeploymentRecord{
		ID:      "", // Will be generated by the store
		Request: *req,
		Status:  Running,
	}
	if err := s.store.Save(record); err != nil {
		return err
	}

	// 3. trigger the deployment using the strategy
	if err := s.strategy.StartDeployment(ctx, record); err != nil {
		return err
	}

	return nil
}

// isRolloutInProgress checks if any deployment is currently running
func (s *TriggerService) isRolloutInProgress() bool {
	runningDeployments, err := s.store.GetByStatus(Running)
	if err != nil {
		return false
	}

	return len(runningDeployments) > 0
}

// GetDeploymentStatus returns all currently running deployments
func (s *TriggerService) GetDeploymentStatus(ctx context.Context) ([]*DeploymentRecord, error) {
	return s.store.GetByStatus(Running)
}

// ProgressDeployment checks instance states and progresses the deployment
func (s *TriggerService) ProgressDeployment(ctx context.Context) (*DeploymentRecord, error) {
	if err := s.lock.Lock(ctx, lockKey); err != nil {
		return nil, err
	}
	defer s.lock.Unlock(ctx, lockKey)

	// 1. Get the deployment record
	records, err := s.store.GetByStatus(Running)
	if err != nil {
		return nil, err
	}

	if len(records) == 0 {
		return nil, nil
	}

	if len(records) != 1 {
		return nil, ErrMoreThanOneInflightDeployment
	}

	// 2. Use the strategy to progress the deployment
	updatedRecord, err := s.strategy.ProgressDeployment(ctx, records[0])
	if err != nil {
		// Check if failure threshold was exceeded in which case we trigger automatic rollback
		if errors.Is(err, ErrFailureThresholdExceeded) {
			// Mark the current deployment as failed
			updatedRecord.Status = Failed
			if updateErr := s.store.Update(updatedRecord); updateErr != nil {
				return updatedRecord, updateErr
			}

			// Trigger automatic rollback deployment without acquiring locks (we already have them)
			if rollbackErr := s.createRollbackDeployment(ctx, updatedRecord.Request.Labels, updatedRecord.Request.Configuration); rollbackErr != nil {
				// If rollback fails, just return the original error
				return updatedRecord, err
			}

			return updatedRecord, nil
		}
		return updatedRecord, err
	}

	return updatedRecord, nil
}

// TriggerRollback creates a new deployment that rolls back to the previous successful deployment
// Rollback has priority - if a deployment is in progress, it will be cancelled
func (s *TriggerService) TriggerRollback(ctx context.Context, labels map[string]string, config Configuration) error {
	// Concurrency check - we need a lock here in case requests arrive simultaneously
	if err := s.lock.Lock(ctx, lockKey); err != nil {
		return err
	}
	defer s.lock.Unlock(ctx, lockKey)

	return s.createRollbackDeployment(ctx, labels, config)
}

// createRollbackDeployment creates a rollback deployment without acquiring locks (for internal use)
// Rollback has priority - if a deployment is in progress, it will be cancelled
func (s *TriggerService) createRollbackDeployment(ctx context.Context, labels map[string]string, config Configuration) error {
	// 1. Cancel any deployment currently in progress (rollback has priority)
	if s.isRolloutInProgress() {
		runningDeployments, err := s.store.GetByStatus(Running)
		if err != nil {
			return err
		}

		// Cancel all running deployments
		for _, deployment := range runningDeployments {
			deployment.Status = Failed
			if err := s.store.Update(deployment); err != nil {
				return err
			}
		}
	}

	// 2. Reset failed instances before starting rollback
	if err := s.strategy.ResetFailedInstances(ctx, labels); err != nil {
		return fmt.Errorf("failed to reset failed instances: %w", err)
	}

	// 2. Find the most recent completed deployment with the same labels
	previousDeployments, err := s.store.GetByLabelsAndStatus(labels, Completed)
	if err != nil {
		return err
	}

	if len(previousDeployments) == 0 {
		return ErrNoPreviousDeploymentFound
	}

	// 3. Get the most recent completed deployment (first in the sorted list)
	previousDeployment := previousDeployments[0]

	// 4. Create a rollback deployment request
	rollbackRequest := &DeploymentRequest{
		CodeVersion:          previousDeployment.Request.CodeVersion,
		ConfigurationVersion: previousDeployment.Request.ConfigurationVersion,
		Labels:               labels,
		Configuration:        config,
	}

	// 5. Validate the rollback request
	if err := rollbackRequest.Validate(); err != nil {
		return err
	}

	// 6. Save the deployment record
	record := &DeploymentRecord{
		ID:      "", // Will be generated by the store
		Request: *rollbackRequest,
		Status:  Running,
	}
	if err := s.store.Save(record); err != nil {
		return err
	}

	// 7. Start the rollback deployment using the strategy
	return s.strategy.StartDeployment(ctx, record)
}
