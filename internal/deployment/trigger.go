package deployment

import (
	"context"
	"errors"

	"github.com/xnok/dides/internal/inventory"
)

const (
	lockKey = "deployment"
)

//go:generate mockgen -source=trigger.go -destination=mocks/mock_store.go -package=mocks

var (
	ErrInvalidDeploymentRequest = errors.New("invalid deployment request")
	ErrRolloutInProgress        = errors.New("deployment rollout in progress")
	ErrDeploymentNotFound       = errors.New("deployment not found")
)

type Store interface {
	Save(req *DeploymentRecord) error
	GetByStatus(status DeploymentStatus) ([]*DeploymentRecord, error)
	Update(record *DeploymentRecord) error
}

type InventoryService interface {
	// GetInstancesByLabels returns instances that match the given labels
	GetInstancesByLabels(labels map[string]string) ([]*inventory.Instance, error)
	// UpdateDesiredState sets the desired state for an instance
	UpdateDesiredState(instanceKey string, state inventory.State) error
	// Efficient methods for deployment logic
	CountByLabels(labels map[string]string) int
	GetNeedingUpdate(labels map[string]string, desiredState inventory.State, opts *inventory.GetNeedingUpdateOptions) ([]*inventory.Instance, error)
	CountNeedingUpdate(labels map[string]string, desiredState inventory.State) (int, error)
}

type Locker interface {
	Lock(ctx context.Context, key string) error
	Unlock(ctx context.Context, key string) error
}

type TriggerService struct {
	store     Store
	lock      Locker
	inventory InventoryService
}

func NewTriggerService(store Store, lock Locker, inventory InventoryService) *TriggerService {
	return &TriggerService{
		store:     store,
		lock:      lock,
		inventory: inventory,
	}
}

// Validate the deployment request
func (r DeploymentRequest) Validate() error {
	// TODO: validate the content of the request (eg. is the version valid)
	if r.CodeVersion == "" {
		return ErrInvalidDeploymentRequest
	}
	return nil
}

// TriggerDeployment initiates a new deployment
func (s *TriggerService) TriggerDeployment(ctx context.Context, req *DeploymentRequest) error {
	if err := req.Validate(); err != nil {
		return err
	}

	// Concurency check we need a lock here in case two or more requests has arrived
	if err := s.lock.Lock(ctx, lockKey); err != nil {
		return err
	}
	defer s.lock.Unlock(ctx, lockKey)

	// 1. Feature Request: If a deployment rollout is in progress, a new deployment rollout cannot start
	if s.isRolloutInProgress() {
		return ErrRolloutInProgress
	}

	// 2. Save the deployment record
	record := &DeploymentRecord{
		ID:      "", // Will be generated by the store
		Request: *req,
		Status:  Running,
	}
	if err := s.store.Save(record); err != nil {
		return err
	}

	// 3. trigger the deployment
	if err := s.startDeployment(record); err != nil {
		return err
	}

	return nil
}

func (s *TriggerService) isRolloutInProgress() bool {
	runningDeployments, err := s.store.GetByStatus(Running)
	if err != nil {
		return false
	}

	return len(runningDeployments) > 0
}
