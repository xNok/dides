package deployment

import (
	"context"
	"errors"
)

const (
	lockKey = "deployment"
)

//go:generate mockgen -source=trigger.go -destination=mocks/mock_store.go -package=mocks
//go:generate mockgen -source=strategy.go -destination=mocks/mock_strategy.go -package=mocks

var (
	ErrInvalidDeploymentRequest      = errors.New("invalid deployment request")
	ErrRolloutInProgress             = errors.New("deployment rollout in progress")
	ErrDeploymentNotFound            = errors.New("deployment not found")
	ErrMoreThanOneInflightDeployment = errors.New("more than one inflight deployment found")
)

type Store interface {
	Save(req *DeploymentRecord) error
	GetByStatus(status DeploymentStatus) ([]*DeploymentRecord, error)
	Update(record *DeploymentRecord) error
}

type Locker interface {
	Lock(ctx context.Context, key string) error
	Unlock(ctx context.Context, key string) error
}

type TriggerService struct {
	store    Store
	lock     Locker
	strategy DeploymentStrategy
}

func NewTriggerService(store Store, lock Locker, strategy DeploymentStrategy) *TriggerService {
	return &TriggerService{
		store:    store,
		lock:     lock,
		strategy: strategy,
	}
}

// Validate the deployment request
func (r DeploymentRequest) Validate() error {
	// TODO: validate the content of the request (eg. is the version valid)
	if r.CodeVersion == "" {
		return ErrInvalidDeploymentRequest
	}
	return nil
}

// TriggerDeployment initiates a new deployment
func (s *TriggerService) TriggerDeployment(ctx context.Context, req *DeploymentRequest) error {
	if err := req.Validate(); err != nil {
		return err
	}

	// Concurency check we need a lock here in case two or more requests has arrived
	if err := s.lock.Lock(ctx, lockKey); err != nil {
		return err
	}
	defer s.lock.Unlock(ctx, lockKey)

	// 1. Feature Request: If a deployment rollout is in progress, a new deployment rollout cannot start
	if s.isRolloutInProgress() {
		return ErrRolloutInProgress
	}

	// 2. Save the deployment record
	record := &DeploymentRecord{
		ID:      "", // Will be generated by the store
		Request: *req,
		Status:  Running,
	}
	if err := s.store.Save(record); err != nil {
		return err
	}

	// 3. trigger the deployment using the strategy
	if err := s.strategy.StartDeployment(record); err != nil {
		return err
	}

	return nil
}

func (s *TriggerService) isRolloutInProgress() bool {
	runningDeployments, err := s.store.GetByStatus(Running)
	if err != nil {
		return false
	}

	return len(runningDeployments) > 0
}

// GetDeploymentStatus returns all currently running deployments
func (s *TriggerService) GetDeploymentStatus() ([]*DeploymentRecord, error) {
	return s.store.GetByStatus(Running)
}

// ProgressDeployment checks instance states and progresses the deployment
func (s *TriggerService) ProgressDeployment(ctx context.Context) (*DeploymentRecord, error) {
	if err := s.lock.Lock(ctx, lockKey); err != nil {
		return nil, err
	}
	defer s.lock.Unlock(ctx, lockKey)

	// 1. Get the deployment record
	records, err := s.store.GetByStatus(Running)
	if err != nil {
		return nil, err
	}

	if len(records) == 0 {
		return nil, nil
	}

	if len(records) != 1 {
		return nil, ErrMoreThanOneInflightDeployment
	}

	// 2. Use the strategy to progress the deployment
	return s.strategy.ProgressDeployment(ctx, records[0])
}
